<!DOCTYPE html>
<html>

<head>
	<title>Webgraph interface</title>
	<!-- <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>	 -->
	<script type="text/javascript" src="vis-network.min.js"></script>
	<link href="data:image/x-icon;base64,YourBase64StringHere" rel="icon" type="image/x-icon" />
	<link rel="stylesheet" href="https://www.w3schools.com/w3css/5/w3.css">
	<!-- <meta name="viewport"
		content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui"> -->
	<!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->
	<!-- <style>
		#network {
			width: 100%;
			height: 1000px;
			border: 1.618px solid lightgray;
		}
	</style> -->
</head>

<body>
	<div class="w3-container">
		<h1 class="w3-serif">Webgraph interface</h1>

		<div class="w3-container ">
			<ul class="w3-ul w3-border w3-round">
				<li>Graph name: <span id="graph_name"></span></li>
				<li>|V|: <span id="graph_V" class="w3-monospace">0</span></li>
				<li>|E|: <span id="graph_E" class="w3-monospace">0</span></li>
				<li>Queue length: <span id="queue_length" class="w3-monospace">0</span></li>
			</ul>
		</div>
	</div>

	<div class="w3-container w3-margin">
		<div id="network" class="w3-card w3-border w3-round" style="height: 1000px;"></div>

		<div class="w3-container w3-border w3-round w3-margin-top w3-padding">
			<p>Controls:

				<input id="explore_nodes" class="w3-check w3-margin-left" type="checkbox" checked="checked">
				<label>Keep exploring nodes</label>

				<input id="explore_edges" class="w3-check w3-margin-left" type="checkbox" checked="checked">
				<label>Keep adding edges</label>
			</p>
		</div>

	</div>

	<script>


		let topic = 'ag';
		let graph_name = 'ag';

		let queue = [759389];
		let edges_queue = []; // This will hold edges to be added

		document.getElementById('graph_name').innerText = graph_name;

		const nodes = new vis.DataSet([]);
		const edges = new vis.DataSet([]);
		const seen = new Set();

		function addNode(id, value = 1) {
			let n = { id: id, label: id.toString(), value: value };
			let nn = nodes.add(n);
			document.getElementById('graph_V').innerText = nodes.length;
			return nn;
		}

		queue.forEach(addNode);

		// Create a network
		const container = document.getElementById('network');
		const data = { nodes, edges };
		const options = {
			nodes: {
				shape: 'dot',
				size: 1,
				// font: { size: 14, color: '#343a40' },
				// borderWidth: 2,
			},
			edges: { smooth: { type: "dynamic" } },
			physics: { stabilization: { iterations: 10 } },
		};
		const network = new vis.Network(container, data, options);

		let sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

		setInterval(() => {
			if (document.getElementById('explore_edges').checked && edges_queue.length > 0) {

				let e = edges_queue.shift();

				if (!nodes.get(e.from)) {
					addNode(e.from, e.from_outdegree);
				}

				if (!nodes.get(e.to)) {
					addNode(e.to, e.to_outdegree);
				}

				edges.add(e);
			}

			document.getElementById('graph_E').innerText = edges.length;
		}, ((1 / 1.618) / 1.618));

		setInterval(async () => {

			if (document.getElementById('explore_nodes').checked && queue.length > 0) {

				let each = queue.shift();

				if (!seen.has(each)) {

					seen.add(each);

					await fetch(`/webgraph-api/neighborhood/${topic}/${graph_name}/${each}`)
						.then(response => response.json())
						.then(data => {
							data.neighborhood.forEach(pair => {

								let neighbor = pair[0];

								if (!seen.has(neighbor)) {
									queue.push(neighbor);
								}

								edges_queue.push({
									from: each,
									to: neighbor,
									arrows: 'to',
									from_outdegree: data.outdegree,
									to_outdegree: pair[1]
								});
							});

							if (nodes.get(each)) {
								nodes.update([{ id: each, color: { background: 'lightgray' } }]);
							}
						})
						.catch(error => console.error('Error fetching neighbors:', error));
				}

				document.getElementById('queue_length').innerText = queue.length;
			}

		}, ((1 / 1.618) / 1));


	</script>
</body>

</html>